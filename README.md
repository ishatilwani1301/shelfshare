## **SHELFSHARE**

## Project Overview

Shelfshare is an open-source, virtual book library application. Users can access their issues from anywhere, anytime! Being a full stack application, users can register, login and even add their own books to the library as well! It enables individuals to browse, share, and access books while maintaining privacy. 


## Project Contributors:
* Isha Tilwani
* Harshita Padmanabhuni
* Ashish Kumar
* Ghousiya Begum

## Purpose :- 


# ðŸ¥³ Features
- âœ… New users can register for Shelfshare
- âœ… Allows users to login and logout
- âœ… Allows users to browse the public library (all available books)
- âœ… Users can issue books from the library
- âœ… Users can add books to their bookshelf
- âœ… Allows users to return(forward to other user) their issued books
- âœ… Update the number of available and issued books in the library for transparency
- âœ… Users shouldn't be able to view other's bookshelves
- âœ… Creates a custom route for each user associated with their userID
- âœ… Doesn't allow to access library without signing in
- âœ… Doesn't allow to submit new book without all information
- âœ… **Book Management:** Add, view, and manage your books.
- âœ… **Note Taking:** Add multiple notes for each book.
- âœ…**AI-Powered Summarization:** Automatically generates a concise summary of all notes for a given book.
    * Summarization is triggered asynchronously when a new note is added, ensuring a smooth user experience.
    * Summaries are generated by synthesizing content from *all* notes for a specific book.
- âœ…**Decoupled Architecture:** Separates the backend API (Spring Boot) from the AI summarization service (Python).
- âœ…**Data Persistence:** Stores book and note data in a relational database.
- âœ… **Anonymous Book Sharing:** Users can share books without revealing personal details.
- âœ… **Notes Integration:** Books can have associated notes for additional context.
- âœ… **Search and Filter:** Browse books by genre, author, or location.
- âœ… User can send Book Borrow Request, Accept Borrow Resquest or approve it.





## Architecture

The project consists of a backend built with Spring Boot and a frontend developed using modern web technologies.

The project consists of four main components:

1.  **Spring Boot Backend (Java):**
    * Serves as the main API for managing books and notes.
    * Handles data persistence (to the PostgreSQL/MySQL database).
    * Triggers the AI summarization process asynchronously.
    * Fetches and displays the AI-generated summaries.

2.  **AI Summarization Service (Python):**
    * A lightweight web service (using Flask or FastAPI) that exposes an API endpoint for summarization.
    * Loads a pre-trained Hugging Face summarization model (e.g., `distilbart-cnn-12-6`).
    * Receives combined note text from the Spring Boot backend, performs inference, and returns the summary.

3.  **Database (PostgreSQL):**
    * Stores `Books` information (including the generated summary).
    * Stores `Notes` associated with each book.
    * Store `Users` information.

4. **Frontend (React.js):**
    Better User Experience, and UI purpose



## Technologies Used

* **Backend:**
    * Java 17+ (24)
    * Spring Boot 3.x
    * Spring Data JPA
    * Gradle
* **AI Service:**
    * Python 3.9+
    * Flask (or FastAPI)
    * Transformers (Falconsai)
* **Database:**
    * PostgreSQL 
* **Deployment (for production/demo):** //to be done
    * Cloud Providers (e.g., AWS, GCP, DigitalOcean) for VMs or Serverless Functions.
    * Docker (optional, for containerization)
* **Frontend:**
    * React.js 

## Setup and Installation

### Prerequisites

* Java 17+ SDK installed
* Gradle installed
* Python 3.9+ installed
* `pip` (Python package installer)
* A running PostgreSQL database instance.

### 1. Database Setup

1.  Create a new database (e.g., `shelfshare`).
2.  Update your Spring Boot `application.properties`  with your database connection details.

    ```spring.application.name=shelfshare
    server.port=1234
    spring.datasource.url=jdbc:postgresql://localhost:5432/shelfshare
    spring.datasource.username=<usernmame>
    spring.datasource.password=<password>
    spring.jpa.show-sql=true
    spring.jpa.hibernate.format_sql=true
    spring.jpa.hibernate.highlight_sql=true
    spring.jpa.hibernate.ddl-auto=update 

    logging.level.org.springframework.security=DEBUG# or MySQLDialect
    ```

### 2. Spring Boot Backend Setup

1.  Clone the repository:
    ```bash
    git clone https://gitlab.com/pvgharshita/shelfshare.git
    cd backend/shelfshare # or your project directory
    ```
2.  Build the project:
    ```bash
    gradle clean build
    ```
3.  Configure AI Service URL: //to be done
    * In `src/main/resources/application.properties`, add the URL for your Python AI service. If running locally, it might be `http://localhost:5000/summarize`.
    ```properties
    ai.summarization.service.url=http://localhost:5000/summarize
    ```
4.  Run the Spring Boot application:
    ```bash
    gradle bootRun
    ```
    The application will start on `http://localhost:1234` 
### 3. AI Summarization Service (Python) Setup

1.  cd ai-summarizer-service # or your project directory
    ```
2.  Create a virtual environment (recommended):
    ```bash
    python -m venv venv
    source venv/bin/activate # On Windows: .\venv\Scripts\activate
    ```
3.  Install dependencies:
    ```bash
    pip install -r requirements.txt
    # Example requirements.txt content:
    # Flask==2.x.x
    # transformers==4.x.x
    # torch==2.x.x # or tensorflow==2.x.x if using TF
    ```
4.  Run the Flask/FastAPI application:
    ```bash
    python app.py # Assuming your Flask app is in app.py
    # Or for FastAPI: uvicorn main:app --reload
    ```
    The AI service will typically run on `http://localhost:5000`.

## 4. Frontend Setup:
1. Go to backend/ folder.
2. npm install
3. npm run dev

---

## Folder Structure

### Backend (`shelfshare/backend`)
The backend handles API requests, business logic, and database interactions.

#### Key Components:
- **Controllers:** Manage HTTP endpoints.
  - Example: `AnonymousBookController.java`
- **Services:** Contain core business logic.
  - Example: `BookService.java`, `NotesService.java`
- **Entities:** Represent database tables.
  - Example: `Books.java`, `Notes.java`
- **Models:** Define response structures.
  - Example: `AnonymousBookResponse.java`

#### Backend Features:
- RESTful API endpoints.
- Integration with MySQL database.
- Dependency management using Gradle.

---

### Frontend (`shelfshare/frontend`)
The frontend provides the user interface for interacting with the platform.

#### Key Components:
- **React Components:** Modular UI elements.
- **Axios:** Handles API requests.
- **Tailwind CSS:** Provides styling and responsive design.

#### Frontend Features:
- Book browsing and searching.
- Display of all available books.
- Display of borrowed Books of a user.
- Display of enlisted books.
- Display of anonymous book details.
- Integration with backend APIs.

---

**Interaction Flow for Summarization Feature:**
1.  User adds a new note via the Spring Boot API.
2.  Spring Boot saves the note to the database.
3.  Spring Boot triggers an **asynchronous** call to the Python AI Summarization Service with all notes for that book.
4.  The Python service processes the notes and returns a summary.
5.  Spring Boot updates the `summarizedNotes` field of the corresponding `Book` in the database.
6.  When a user views book details, the latest available summary is displayed.

## Usage of Summarization Feature

Once both the Spring Boot backend and the AI summarization service are running:

1.  **Add a Book:**
    * Send a `POST` request to `/books/addNewBook` (or similar endpoint) with book details.
    * Initially, the book's `summarizedNotes` field will be empty.

2.  **Add Notes to a Book:**
    * Send a `POST` request to `/notes` (or similar endpoint) with the note content and the associated `bookId`.
    * After adding **at least two notes** for a book, the Spring Boot backend will asynchronously trigger the AI summarization service.
    * The `summarizedNotes` field of the book will be updated in the database once the summarization is complete (this happens in the background, typically taking a few seconds to tens of seconds depending on your AI service's host).

3.  **View Book Details (and Summary):**
    * Send a `GET` request to `/books/{bookId}` (or `/books/all` to see all books).
    * The response will include the `summarizedNotes` field, which will contain the AI-generated summary if available.

## Key Design Decisions & Notes

* **Asynchronous Summarization:** The summarization process is decoupled and runs in the background. This ensures that adding a note is always fast from the user's perspective, even if the AI inference takes time.
* **"Summarize All Notes from Scratch":** Whenever a new note is added, the system fetches *all* notes for that book, combines them, and generates a fresh summary. This ensures the highest quality and most coherent summary, as the AI always sees the full context.
* **Max 20 Notes per Book:** The project is designed with the understanding that a book will have a maximum of 20 notes. This keeps the combined text length manageable, eliminating the need for complex "long document summarization" techniques (like chunking and recursive summarization) and keeping AI inference times within reasonable limits.
* **Cost Efficiency:** For a capstone project, this setup can be implemented entirely for free by leveraging cloud free tiers and CPU-only AI inference, though with a trade-off in AI processing speed.

## Future Enhancements (Ideas)

* **Real-time Summary Updates:** Implement WebSockets to push summary updates to the frontend as soon as they are ready.
* **Error Handling:** Implement more robust error handling and fallback mechanisms for AI service failures.
* **Configurable AI Model:** Allow changing the AI model via configuration without code changes.
* **Summary Quality Evaluation:** Implement metrics to evaluate summary quality.
* **Chat Feature**

## Contribution Guidelines
    We welcome contributions to ShelfShare! To contribute:
    1. Fork the repository.
    2. Create a new branch for your feature or bug fix.
    3. Submit a pull request with a detailed description of your changes.

## License
"Proprietary for Capstone Project"

---